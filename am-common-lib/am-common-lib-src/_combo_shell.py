# DO NOT EDIT THIS FILE.
"""A bash-like mini-shell for cross-platform command chaining within Pipfile scripts.

Command execution closely mimics basic bash-like shell behavior with respect to the
operators ``&&``, ``||``, and ``;``. However, this is a pure Python implementation that
does not depend on bash or any other shell. Running

    python _combo_shell.py <cmd-string>

should be equivalent to:

    bash -c <cmd-string>

**Usage (in a Pipfile script)**:
    python _combo_shell.py "<command> [[<op> <command>] ...]"

**Example**:
    python _combo_shell.py "echo start && do-thing || echo failed ; echo done"

**Supported operators**:

- ``&&`` : Run next command only if the previous succeeded
- ``||`` : Run next command only if the previous failed
- ``;``  : Always run the next command
"""

import shlex
import subprocess
import sys


def main() -> None:  # noqa: C901
    if len(sys.argv) != 2:
        print(
            "Usage: "
            f'{sys.argv[0]} "<command1> && <command2> || <command3> ; <command4>"\n'
            "Mimics 'bash -c' behavior for command chaining, "
            "but runs natively in Python.\n"
            "Supports:\n"
            "  &&    Run next command only if the previous succeeded\n"
            "  ||    Run next command only if the previous failed\n"
            "   ;    Always run the next command",
            file=sys.stderr,
        )
        sys.exit(2)

    input_command = sys.argv[1]
    tokens = shlex.split(input_command)

    # Group tokens into commands with operators
    commands = []
    current_cmd: list[str] = []
    operators = []
    i = 0
    while i < len(tokens):
        token = tokens[i]
        if token in ("&&", "||", ";"):
            commands.append(current_cmd)
            operators.append(token)
            current_cmd = []
        else:
            current_cmd.append(token)
        i += 1
    if current_cmd:
        commands.append(current_cmd)

    last_exit_code = 0
    for i, cmd in enumerate(commands):
        # Determine whether to run this command
        if i > 0:
            op = operators[i - 1]
            if op == "&&" and last_exit_code != 0 or op == "||" and last_exit_code == 0:
                continue
            # for ';' or any case that falls through, we continue to run

        print(f"Running: {' '.join(cmd)}", file=sys.stderr)
        try:
            result = subprocess.run(cmd, check=True)
            last_exit_code = result.returncode
        except subprocess.CalledProcessError as e:
            last_exit_code = e.returncode
            print(
                f"Command failed with exit code {e.returncode}: {' '.join(cmd)}",
                file=sys.stderr,
            )

    sys.exit(last_exit_code)


if __name__ == "__main__":
    main()
